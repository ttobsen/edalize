# Copyright edalize contributors
# Licensed under the 2-Clause BSD License, see LICENSE for details.
# SPDX-License-Identifier: BSD-2-Clause

import os
import logging

from edalize.edatool import Edatool

logger = logging.getLogger(__name__)

MAKE_HEADER = """#Generated by Edalize

QVERIFY ?= qverify

QVERIFY_OPTIONS  ?= {qverify_options}

all: work

run: work
	$(QVERIFY) $(QVERIFY_OPTIONS) -do {qverify_do}

run-gui: work
	$(QVERIFY) -gui

work:
	$(QVERIFY) -c -do "do edalize_main.tcl; exit"

clean:
"""


class Questaformal(Edatool):

    argtypes = ["plusarg", "vlogdefine", "vlogparam", "generic"]

    @classmethod
    def get_doc(cls, api_ver):
        if api_ver == 0:
            return {
                "description": "Questa Formal from Mentor Graphics",
                "lists": [
                    {
                        "name": "vcom_options",
                        "type": "String",
                        "desc": "Additional options for compilation with vcom",
                    },
                    {
                        "name": "vlog_options",
                        "type": "String",
                        "desc": "Additional options for compilation with vlog",
                    },
                    {
                        "name": "qverify_options",
                        "type": "String",
                        "desc": "Additional run options for qverify",
                    },
                    {
                        "name": "qverify_do_files",
                        "type": "String",
                        "desc": "List of do files to run with qverify",
                    },
                    {
                        "name": "autocheck_options",
                        "type": "String",
                        "desc": "Options for Autochecker",
                    },
                ],
            }

    def _write_build_rtl_tcl_file(self, tcl_main):
        tcl_build_rtl = open(os.path.join(self.work_root, "edalize_build_rtl.tcl"), "w")

        (src_files, incdirs) = self._get_fileset_files()
        vlog_include_dirs = ["+incdir+" + d.replace("\\", "/") for d in incdirs]

        libs = []
        for f in src_files:
            if not f.logical_name:
                f.logical_name = "work"
            if not f.logical_name in libs:
                tcl_build_rtl.write("vlib {}\n".format(f.logical_name))
                libs.append(f.logical_name)
            if f.file_type.startswith("verilogSource") or f.file_type.startswith(
                "systemVerilogSource"
            ):
                cmd = "vlog"
                args = []

                args += self.tool_options.get("vlog_options", [])

                for k, v in self.vlogdefine.items():
                    args += ["+define+{}={}".format(k, self._param_value_str(v))]

                if f.file_type.startswith("systemVerilogSource"):
                    args += ["-sv"]
                args += vlog_include_dirs
            elif f.file_type.startswith("vhdlSource"):
                cmd = "vcom"
                if f.file_type.endswith("-87"):
                    args = ["-87"]
                if f.file_type.endswith("-93"):
                    args = ["-93"]
                if f.file_type.endswith("-2008"):
                    args = ["-2008"]
                else:
                    args = []

                args += self.tool_options.get("vcom_options", [])

            elif f.file_type == "tclSource":
                cmd = None
                tcl_main.write("do {}\n".format(f.name))
            elif f.file_type == "user":
                cmd = None
            else:
                _s = "{} has unknown file type '{}'"
                logger.warning(_s.format(f.name, f.file_type))
                cmd = None
            if cmd:
                args += ["-quiet"]
                args += ["-work", f.logical_name]
                args += [f.name.replace("\\", "/")]
                tcl_build_rtl.write("{} {}\n".format(cmd, " ".join(args)))

    def _write_makefile(self):
        _parameters = []
        for key, value in self.vlogparam.items():
            _parameters += ["{}={}".format(key, self._param_value_str(value))]
        for key, value in self.generic.items():
            _parameters += [
                "{}={}".format(key, self._param_value_str(value, bool_is_str=True))
            ]
        _plusargs = []
        for key, value in self.plusarg.items():
            _plusargs += ["{}={}".format(key, self._param_value_str(value))]

        _qverify_options = self.tool_options.get("qverify_options", [])

        _autocheck_options = self.tool_options.get("autocheck_options", [])
        if _autocheck_options:
            _qverify_do = ['"do edalize_autocheck.tcl; exit"']

        _qverify_do_files = self.tool_options.get("qverify_do_files", [])
        if _qverify_do_files:
            _qverify_do = '"'
            for do_file in _qverify_do_files:
                _qverify_do += "do {}; ".format(do_file)
            _qverify_do += 'exit"'

        makefile = open(os.path.join(self.work_root, "Makefile"), "w")
        _s = MAKE_HEADER.format(
            toplevel=self.toplevel,
            parameters=" ".join(_parameters),
            plusargs=" ".join(_plusargs),
            qverify_options=" ".join(_qverify_options),
            qverify_do=_qverify_do,
        )
        makefile.write(_s)
        makefile.close()

    def configure_main(self):
        tcl_main = open(os.path.join(self.work_root, "edalize_main.tcl"), "w")
        tcl_main.write("onerror { quit -code 1; }\n")
        tcl_main.write("do edalize_build_rtl.tcl\n")

        tcl_autocheck = open(os.path.join(self.work_root, "edalize_autocheck.tcl"), "w")
        _autocheck_options = self.tool_options.get("autocheck_options", [])
        for ac_option in _autocheck_options:
            tcl_autocheck.write("autocheck {}\n".format(ac_option))
        tcl_autocheck.close()

        self._write_build_rtl_tcl_file(tcl_main)
        self._write_makefile()
        tcl_main.close()

    def run_main(self):
        args = ["run"]

        # Set plusargs
        if self.plusarg:
            plusargs = []
            for key, value in self.plusarg.items():
                plusargs += ["{}={}".format(key, self._param_value_str(value))]
            args.append("PLUSARGS=" + " ".join(plusargs))

        self._run_tool("make", args)
